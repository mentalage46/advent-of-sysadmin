# Saint John: 로그 파일 무단 작성 프로세스 종료 가이드

이 가이드는 `/var/log/bad.log` 파일에 지속적으로 데이터를 기록하여 디스크 공간을 점유하는 프로세스를 찾아 안전하게 종료하는 방법을 설명합니다.

## 1. 문제 상황 분석 (Scenario)

- **현상**: 특정 프로그램이 `/var/log/bad.log` 파일에 끊임없이 로그를 남겨 디스크 용량을 가득 채우고 있습니다.
- **목표**: 해당 로그 파일을 작성 중인 프로그램을 찾아 종료합니다. (로그 파일 자체는 삭제하지 않습니다.)
- **확인 방법**: `tail -f /var/log/bad.log` 명령어로 실시간 기록 여부를 확인할 수 있습니다.

---

## 2. 해결 단계 (Solution Steps)

### 1단계: 로그 파일 상태 확인

먼저 파일이 실제로 계속 커지고 있는지 확인합니다.

```bash
tail -f /var/log/bad.log
```

실시간으로 텍스트가 올라온다면 프로세스가 활성화된 상태입니다.

### 2단계: 파일을 열고 있는 프로세스 식별 (`lsof`)

어떤 프로그램이 이 파일을 사용 중인지 확인하기 위해 `lsof` 명령어를 사용합니다.

```bash
sudo lsof /var/log/bad.log
```

- **출력 예시**:
  ```
  COMMAND   PID  USER   FD   TYPE DEVICE SIZE/OFF   NODE NAME
  python3  1234 admin    3w   REG    8,1  1048576  12345 /var/log/bad.log
  ```
- 여기서 **PID**(Process ID)인 `1234`를 기억해야 합니다.

### 3단계: 프로세스 종료 (`kill`)

찾아낸 PID를 이용해 프로세스를 종료합니다.

```bash
sudo kill 1234
```

만약 정상적으로 종료되지 않는다면 강제 종료 옵션(`-9`)을 사용합니다.

```bash
sudo kill -9 1234
```

### 4단계: 결과 검증

파일 크기가 더 이상 늘어나지 않는지 확인합니다.

```bash
ls -l /var/log/bad.log
# 잠시 후 다시 실행하여 파일 크기 비교
```

---

## 3. 주요 리눅스 명령어 상세 설명

### 🔍 `lsof` (List Open Files)

리눅스 시스템에서 **열려 있는 모든 파일의 목록**을 보여주는 명령어입니다. 리눅스는 "모든 것이 파일이다(Everything is a file)"라는 철학을 가지고 있어, 네트워크 소켓, 디렉토리, 장치 등도 이 명령어로 확인할 수 있습니다.

- **사용법**: `lsof [파일 경로]`
- **주요 필드**:
  - `COMMAND`: 프로세스 실행 이름
  - `PID`: 프로세스 고유 번호 (종료 시 필요)
  - `USER`: 프로세스를 실행한 사용자
  - `FD`: 파일 디스크립터 (w는 쓰기 권한을 의미)

### 🔪 `kill`

실행 중인 **프로세스에 시그널(Signal)을 보내는** 명령어입니다. 주로 프로세스를 종료할 때 사용합니다.

- **사용법**: `kill [시그널 옵션] [PID]`
- **주요 시그널**:
  - `15 (SIGTERM)`: 기본값. 프로세스에게 "정상적으로 정리하고 종료해라"라고 요청합니다.
  - `9 (SIGKILL)`: 강제 종료. 프로세스가 즉시 중단됩니다. 데이터 손실 위험이 있으므로 `SIGTERM`으로 안 될 때만 사용합니다.

### 📜 `tail`

파일의 **뒷부분**을 출력하는 명령어입니다.

- **옵션 `-f` (follow)**: 파일에 새로운 내용이 추가될 때마다 실시간으로 화면에 출력합니다. 로그 모니터링에 필수적입니다.

### 📊 `du` (Disk Usage)

파일이나 디렉토리가 사용하는 **디스크 용량**을 확인합니다.

- **옵션 `-h` (human-readable)**: 용량을 KB, MB, GB 단위로 읽기 쉽게 표시합니다.
- **예시**: `du -h /var/log/bad.log`
